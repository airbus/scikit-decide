(window.webpackJsonp=window.webpackJsonp||[]).push([[139],{653:function(e,a,t){"use strict";t.r(a);var r=t(38),s=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"hub-solver-ray-rllib-ray-rllib"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hub-solver-ray-rllib-ray-rllib"}},[e._v("#")]),e._v(" hub.solver.ray_rllib.ray_rllib")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("Domain specification")]),e._v(" "),t("skdecide-summary")],1),e._v(" "),t("h2",{attrs:{id:"rayrllib"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rayrllib"}},[e._v("#")]),e._v(" RayRLlib")]),e._v(" "),t("p",[e._v("This class wraps a Ray RLlib solver (ray[rllib]) as a scikit-decide solver.")]),e._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[e._v("WARNING")]),e._v(" "),t("p",[e._v("Using this class requires Ray RLlib to be installed.")])]),e._v(" "),t("h3",{attrs:{id:"constructor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[e._v("#")]),e._v(" Constructor "),t("Badge",{attrs:{text:"RayRLlib",type:"tip"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"RayRLlib",sig:{params:[{name:"domain_factory",annotation:"Callable[[], Domain]"},{name:"algo_class",annotation:"type[Algorithm]"},{name:"train_iterations",annotation:"int"},{name:"config",default:"None",annotation:"Optional[AlgorithmConfig]"},{name:"policy_configs",default:"None",annotation:"Optional[dict[str, dict]]"},{name:"policy_mapping_fn",default:"None",annotation:"Optional[Callable[[str, Optional['EpisodeV2'], Optional['RolloutWorker']], str]]"},{name:"action_embed_sizes",default:"None",annotation:"Optional[dict[str, int]]"},{name:"callback",default:"<lambda function>",annotation:"Callable[[RayRLlib], bool]"},{name:"graph_feature_extractors_kwargs",default:"None",annotation:"Optional[dict[str, Any]]"},{name:"graph_node_action",default:"False",annotation:"bool"},{name:"graph_node_action_net_kwargs",default:"None",annotation:"Optional[dict[str, Any]]"},{name:"**kwargs"}],return:"None"}}}),e._v(" "),t("p",[e._v("Initialize Ray RLlib.")]),e._v(" "),t("h4",{attrs:{id:"parameters"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("domain_factory")]),e._v(": A callable with no argument returning the domain to solve (can be a mere domain class).\nThe resulting domain will be auto-cast to the level expected by the solver.")]),e._v(" "),t("li",[t("strong",[e._v("algo_class")]),e._v(": The class of Ray RLlib trainer/agent to wrap.")]),e._v(" "),t("li",[t("strong",[e._v("train_iterations")]),e._v(": The number of iterations to call the trainer's train() method.")]),e._v(" "),t("li",[t("strong",[e._v("config")]),e._v(": The configuration dictionary for the trainer.")]),e._v(" "),t("li",[t("strong",[e._v("policy_configs")]),e._v(": The mapping from policy id (str) to additional config (dict) (leave default for single policy).")]),e._v(" "),t("li",[t("strong",[e._v("policy_mapping_fn")]),e._v(": The function mapping agent ids to policy ids (leave default for single policy).")]),e._v(" "),t("li",[t("strong",[e._v("action_embed_sizes")]),e._v(": The mapping from policy id (str) to action embedding size (only used with domains filtering allowed actions per state, default to 2)")]),e._v(" "),t("li",[t("strong",[e._v("callback")]),e._v(": function called at each solver iteration.\nIf returning true, the solve process stops and exit the current train iteration.\nHowever, if train_iterations > 1, another train loop will be entered after that.\n(One can code its callback in such a way that further training loop are stopped directly after that.)\ngraph_feature_extractors_kwargs: in case of graph observations, these are the kwargs to the "),t("code",[e._v("GraphFeaturesExtractor")]),e._v(" model\nused to extract features. See "),t("code",[e._v("skdecide.hub.solver.utils.gnn.torch_layers.GraphFeaturesExtractor")]),e._v(".\ngraph_node_action: specify if actions are actually nodes of the observation graph. In that case, the actual action space\nsize is derived at runtime from the observation graph.\ngraph_node_action_net_kwargs: if graph_node_action, these are the kwargs to the "),t("code",[e._v("Graph2NodeLayer")]),e._v(" model used to\npredict actions from the observation. See "),t("code",[e._v("skdecide.hub.solver.utils.gnn.torch_layers.Graph2NodeLayer")]),e._v(".\n**kwargs: used to update the algo config with kwargs automatically filled by optuna.")])]),e._v(" "),t("h4",{attrs:{id:"masking"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#masking"}},[e._v("#")]),e._v(" Masking")]),e._v(" "),t("p",[e._v("If the domain has not the "),t("code",[e._v("UnrestrictedActions")]),e._v(" mixin, and if the algo used allows action masking\n(e.g. APPO, BC, DQN, Rainbow, IMPALA, MARWIL, PPO), the observations are automatically wrapped to also present\nthe action mask to the algorithm, which will used via a custom model\n(defined in "),t("code",[e._v("skdecide.hub.solver.ray_rllib.action_masking.models")]),e._v(").\nDuring training, a gymnasium environment is created wrapping a domain instantiated from "),t("code",[e._v("domain_factory")]),e._v(" and\nused during training rollouts to get the observation with the appropriate action mask.\nAt inference, we use the method "),t("code",[e._v("self.get_action_mask()")]),e._v(" which provides the proper action mask provided that\n"),t("code",[e._v("self.retrieve_applicable_actions(domain)")]),e._v(" has been called before hand with the domain instance used for the inference.\nThis is automatically done by "),t("code",[e._v("skdecide.utils.rollout()")]),e._v(".")]),e._v(" "),t("h4",{attrs:{id:"graph-observations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#graph-observations"}},[e._v("#")]),e._v(" Graph observations")]),e._v(" "),t("p",[e._v("If the observation space wrapped gymnasium space for each agent is a "),t("code",[e._v("gymnasium.spaces.Graph")]),e._v(" or a "),t("code",[e._v("gymnasium.spaces.Dict")]),e._v("\nwhose subspaces contain a "),t("code",[e._v("gymnasium.spaces.Graph")]),e._v(", the solver will use custom models adapted to graphs for its policy, using GNNs.")]),e._v(" "),t("ul",[t("li",[e._v("If "),t("code",[e._v("graph_node_action")]),e._v(" is False (default), a GNN will be used to extract (a fixed number of) features from graphs,\nand then classical MLPs will be use for predicting action and value.\nSee "),t("code",[e._v("skdecide.hub.solver.utils.gnn.torch_layers.GraphFeaturesExtractor")]),e._v(" for more details\nand use "),t("code",[e._v("graph_feature_extractors_kwargs")]),e._v(" to customize it.")]),e._v(" "),t("li",[e._v("If "),t("code",[e._v("graph_node_action")]),e._v(" is True, this means that an agent action is defined by the choice of node in the observation graph.\nThe agent action space should wrap a "),t("code",[e._v("gymnasium.spaces.Discrete")]),e._v(" even though the actual number of actions will be\nderived at runtime from the number of nodes in the observation graph. The agent observation wrapped gymnasium space\ncan only be a "),t("code",[e._v("gymnasium.spaces.Graph")]),e._v(" in that case.\nThe value is still predicted as above via a GNN features extractor + classical MLP, customized with same parameters.\nThe action logits will be directly predicted via another GNN so that the number of logits correspond to the number\nof nodes.\nSee "),t("code",[e._v("skdecide.hub.solver.utils.gnn.torch_layers.Graph2NodeLayer")]),e._v(" for more details\nand use "),t("code",[e._v("graph_node_action_net_kwargs")]),e._v(" to customize it.")])]),e._v(" "),t("h3",{attrs:{id:"autocast"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#autocast"}},[e._v("#")]),e._v(" autocast "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"autocast",sig:{params:[{name:"self"},{name:"domain_cls",default:"None",annotation:"Optional[type[Domain]]"}],return:"None"}}}),e._v(" "),t("p",[e._v("Autocast itself to the level corresponding to the given domain class.")]),e._v(" "),t("h4",{attrs:{id:"parameters-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-2"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("domain_cls")]),e._v(": the domain class to which level the solver needs to autocast itself.\nBy default, use the original domain factory passed to its constructor.")])]),e._v(" "),t("h3",{attrs:{id:"check-domain"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#check-domain"}},[e._v("#")]),e._v(" check_domain "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"check_domain",sig:{params:[{name:"domain",annotation:"Domain"}],return:"bool"}}}),e._v(" "),t("p",[e._v("Check whether a domain is compliant with this solver type.")]),e._v(" "),t("p",[e._v("By default, "),t("code",[e._v("Solver.check_domain()")]),e._v(" provides some boilerplate code and internally\ncalls "),t("code",[e._v("Solver._check_domain_additional()")]),e._v(' (which returns True by default but can be overridden  to define\nspecific checks in addition to the "domain requirements"). The boilerplate code automatically checks whether all\ndomain requirements are met.')]),e._v(" "),t("h4",{attrs:{id:"parameters-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-3"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("domain")]),e._v(": The domain to check.")])]),e._v(" "),t("h4",{attrs:{id:"returns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),t("p",[e._v("True if the domain is compliant with the solver type (False otherwise).")]),e._v(" "),t("h3",{attrs:{id:"complete-with-default-hyperparameters"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#complete-with-default-hyperparameters"}},[e._v("#")]),e._v(" complete_with_default_hyperparameters "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"complete_with_default_hyperparameters",sig:{params:[{name:"kwargs",annotation:"dict[str, Any]"},{name:"names",default:"None",annotation:"Optional[list[str]]"}]}}}),e._v(" "),t("p",[e._v("Add missing hyperparameters to kwargs by using default values")]),e._v(" "),t("p",[e._v("Args:\nkwargs: keyword arguments to complete (e.g. for "),t("code",[e._v("__init__")]),e._v(", "),t("code",[e._v("init_model")]),e._v(", or "),t("code",[e._v("solve")]),e._v(")\nnames: names of the hyperparameters to add if missing.\nBy default, all available hyperparameters.")]),e._v(" "),t("p",[e._v("Returns:\na new dictionary, completion of kwargs")]),e._v(" "),t("h3",{attrs:{id:"copy-and-update-hyperparameters"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#copy-and-update-hyperparameters"}},[e._v("#")]),e._v(" copy_and_update_hyperparameters "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"copy_and_update_hyperparameters",sig:{params:[{name:"names",default:"None",annotation:"Optional[list[str]]"},{name:"**kwargs_by_name",annotation:"dict[str, Any]"}],return:"list[Hyperparameter]"}}}),e._v(" "),t("p",[e._v("Copy hyperparameters definition of this class and update them with specified kwargs.")]),e._v(" "),t("p",[e._v("This is useful to define hyperparameters for a child class\nfor which only choices of the hyperparameter change for instance.")]),e._v(" "),t("p",[e._v("Args:\nnames: names of hyperparameters to copy. Default to all.\n**kwargs_by_name: for each hyperparameter specified by its name,\nthe attributes to update. If a given hyperparameter name is not specified,\nthe hyperparameter is copied without further update.")]),e._v(" "),t("p",[e._v("Returns:")]),e._v(" "),t("h3",{attrs:{id:"forget-callback"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#forget-callback"}},[e._v("#")]),e._v(" forget_callback "),t("Badge",{attrs:{text:"RayRLlib",type:"tip"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"forget_callback",sig:{params:[{name:"self"}]}}}),e._v(" "),t("p",[e._v("Forget about actual callback to avoid serializing issues.")]),e._v(" "),t("h3",{attrs:{id:"get-action-mask"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-action-mask"}},[e._v("#")]),e._v(" get_action_mask "),t("Badge",{attrs:{text:"Maskable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"get_action_mask",sig:{params:[{name:"self"}],return:"Optional[D.T_agent[Mask]]"}}}),e._v(" "),t("p",[e._v("Retrieve stored action masks.")]),e._v(" "),t("p",[e._v("To be used by "),t("code",[e._v("self.sample_action()")]),e._v(".\nReturns None if "),t("code",[e._v("self.set_action_mask()")]),e._v(" was not called.")]),e._v(" "),t("h3",{attrs:{id:"get-default-hyperparameters"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-default-hyperparameters"}},[e._v("#")]),e._v(" get_default_hyperparameters "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"get_default_hyperparameters",sig:{params:[{name:"names",default:"None",annotation:"Optional[list[str]]"}],return:"dict[str, Any]"}}}),e._v(" "),t("p",[e._v("Get hyperparameters default values.")]),e._v(" "),t("p",[e._v("Args:\nnames: names of the hyperparameters to choose.\nBy default, all available hyperparameters will be suggested.")]),e._v(" "),t("p",[e._v("Returns:\na mapping between hyperparameter's name_in_kwargs and its default value (None if not specified)")]),e._v(" "),t("h3",{attrs:{id:"get-domain-requirements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-domain-requirements"}},[e._v("#")]),e._v(" get_domain_requirements "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"get_domain_requirements",sig:{params:[],return:"list[type]"}}}),e._v(" "),t("p",[e._v("Get domain requirements for this solver class to be applicable.")]),e._v(" "),t("p",[e._v("Domain requirements are classes from the "),t("code",[e._v("skdecide.builders.domain")]),e._v(" package that the domain needs to inherit from.")]),e._v(" "),t("h4",{attrs:{id:"returns-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns-2"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),t("p",[e._v("A list of classes to inherit from.")]),e._v(" "),t("h3",{attrs:{id:"get-hyperparameter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-hyperparameter"}},[e._v("#")]),e._v(" get_hyperparameter "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"get_hyperparameter",sig:{params:[{name:"name",annotation:"str"}],return:"Hyperparameter"}}}),e._v(" "),t("p",[e._v("Get hyperparameter from given name.")]),e._v(" "),t("h3",{attrs:{id:"get-hyperparameters-by-name"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-hyperparameters-by-name"}},[e._v("#")]),e._v(" get_hyperparameters_by_name "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"get_hyperparameters_by_name",sig:{params:[],return:"dict[str, Hyperparameter]"}}}),e._v(" "),t("p",[e._v("Mapping from name to corresponding hyperparameter.")]),e._v(" "),t("h3",{attrs:{id:"get-hyperparameters-names"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-hyperparameters-names"}},[e._v("#")]),e._v(" get_hyperparameters_names "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"get_hyperparameters_names",sig:{params:[],return:"list[str]"}}}),e._v(" "),t("p",[e._v("List of hyperparameters names.")]),e._v(" "),t("h3",{attrs:{id:"get-policy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-policy"}},[e._v("#")]),e._v(" get_policy "),t("Badge",{attrs:{text:"RayRLlib",type:"tip"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"get_policy",sig:{params:[{name:"self"}],return:"dict[str, Policy]"}}}),e._v(" "),t("p",[e._v("Return the computed policy.")]),e._v(" "),t("h3",{attrs:{id:"is-policy-defined-for"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#is-policy-defined-for"}},[e._v("#")]),e._v(" is_policy_defined_for "),t("Badge",{attrs:{text:"Policies",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"is_policy_defined_for",sig:{params:[{name:"self"},{name:"observation",annotation:"D.T_agent[D.T_observation]"}],return:"bool"}}}),e._v(" "),t("p",[e._v("Check whether the solver's current policy is defined for the given observation.")]),e._v(" "),t("h4",{attrs:{id:"parameters-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-4"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("observation")]),e._v(": The observation to consider.")])]),e._v(" "),t("h4",{attrs:{id:"returns-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns-3"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),t("p",[e._v("True if the policy is defined for the given observation memory (False otherwise).")]),e._v(" "),t("h3",{attrs:{id:"load"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#load"}},[e._v("#")]),e._v(" load "),t("Badge",{attrs:{text:"Restorable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"load",sig:{params:[{name:"self"},{name:"path",annotation:"str"}],return:"None"}}}),e._v(" "),t("p",[e._v("Restore the solver state from given path.")]),e._v(" "),t("p",[e._v("After calling self._load(), autocast itself so that rollout methods apply\nto the domain original characteristics.")]),e._v(" "),t("h4",{attrs:{id:"parameters-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-5"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("path")]),e._v(": The path where the solver state was saved.")])]),e._v(" "),t("h3",{attrs:{id:"reset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reset"}},[e._v("#")]),e._v(" reset "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"reset",sig:{params:[{name:"self"}],return:"None"}}}),e._v(" "),t("p",[e._v("Reset whatever is needed on this solver before running a new episode.")]),e._v(" "),t("p",[e._v("This function does nothing by default but can be overridden if needed (e.g. to reset the hidden state of a LSTM\npolicy network, which carries information about past observations seen in the previous episode).")]),e._v(" "),t("h3",{attrs:{id:"retrieve-applicable-actions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#retrieve-applicable-actions"}},[e._v("#")]),e._v(" retrieve_applicable_actions "),t("Badge",{attrs:{text:"ApplicableActions",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"retrieve_applicable_actions",sig:{params:[{name:"self"},{name:"domain",annotation:"Domain"}],return:"None"}}}),e._v(" "),t("p",[e._v("Retrieve applicable actions and use it for future call to "),t("code",[e._v("self.step()")]),e._v(".")]),e._v(" "),t("p",[e._v("To be called during rollout to get the actual applicable actions from the actual domain used in rollout.\nTransform applicable actions into an action_mask to be use when sampling action.")]),e._v(" "),t("h3",{attrs:{id:"sample-action"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sample-action"}},[e._v("#")]),e._v(" sample_action "),t("Badge",{attrs:{text:"Policies",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"sample_action",sig:{params:[{name:"self"},{name:"observation",annotation:"D.T_agent[D.T_observation]"}],return:"D.T_agent[D.T_concurrency[D.T_event]]"}}}),e._v(" "),t("p",[e._v("Sample an action for the given observation (from the solver's current policy).")]),e._v(" "),t("h4",{attrs:{id:"parameters-6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-6"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("observation")]),e._v(": The observation for which an action must be sampled.")])]),e._v(" "),t("h4",{attrs:{id:"returns-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns-4"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),t("p",[e._v("The sampled action.")]),e._v(" "),t("h3",{attrs:{id:"save"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#save"}},[e._v("#")]),e._v(" save "),t("Badge",{attrs:{text:"Restorable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"save",sig:{params:[{name:"self"},{name:"path",annotation:"str"}],return:"None"}}}),e._v(" "),t("p",[e._v("Save the solver state to given path.")]),e._v(" "),t("h4",{attrs:{id:"parameters-7"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-7"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("path")]),e._v(": The path to store the saved state.")])]),e._v(" "),t("h3",{attrs:{id:"set-action-mask"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set-action-mask"}},[e._v("#")]),e._v(" set_action_mask "),t("Badge",{attrs:{text:"Maskable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"set_action_mask",sig:{params:[{name:"self"},{name:"action_mask",annotation:"Optional[D.T_agent[Mask]]"}],return:"None"}}}),e._v(" "),t("p",[e._v("Set the action mask.")]),e._v(" "),t("p",[e._v("To be called during rollout before "),t("code",[e._v("self.sample_action()")]),e._v(", assuming that\n"),t("code",[e._v("self.sample_action()")]),e._v(" knows what to do with it.")]),e._v(" "),t("p",[e._v("Autocastable so that it can use action_mask from original domain during rollout.")]),e._v(" "),t("h3",{attrs:{id:"set-callback"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set-callback"}},[e._v("#")]),e._v(" set_callback "),t("Badge",{attrs:{text:"RayRLlib",type:"tip"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"set_callback",sig:{params:[{name:"self"}]}}}),e._v(" "),t("p",[e._v("Set back callback.")]),e._v(" "),t("p",[e._v("Useful to do it after serializing/deserializing because of potential issues with")]),e._v(" "),t("ul",[t("li",[e._v("lambda functions")]),e._v(" "),t("li",[e._v("dynamic classes")])]),e._v(" "),t("h3",{attrs:{id:"solve"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#solve"}},[e._v("#")]),e._v(" solve "),t("Badge",{attrs:{text:"FromInitialState",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"solve",sig:{params:[{name:"self"}],return:"None"}}}),e._v(" "),t("p",[e._v("Run the solving process.")]),e._v(" "),t("p",[e._v("After solving by calling self._solve(), autocast itself so that rollout methods apply\nto the domain original characteristics.")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),t("p",[e._v("The nature of the solutions produced here depends on other solver's characteristics like\n"),t("code",[e._v("policy")]),e._v(" and "),t("code",[e._v("assessibility")]),e._v(".")])]),e._v(" "),t("h3",{attrs:{id:"suggest-hyperparameter-with-optuna"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#suggest-hyperparameter-with-optuna"}},[e._v("#")]),e._v(" suggest_hyperparameter_with_optuna "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"suggest_hyperparameter_with_optuna",sig:{params:[{name:"trial",annotation:"optuna.trial.Trial"},{name:"name",annotation:"str"},{name:"prefix",default:"",annotation:"str"},{name:"**kwargs"}],return:"Any"}}}),e._v(" "),t("p",[e._v("Suggest hyperparameter value during an Optuna trial.")]),e._v(" "),t("p",[e._v("This can be used during Optuna hyperparameters tuning.")]),e._v(" "),t("p",[e._v("Args:\ntrial: optuna trial during hyperparameters tuning\nname: name of the hyperparameter to choose\nprefix: prefix to add to optuna corresponding parameter name\n(useful for disambiguating hyperparameters from subsolvers in case of meta-solvers)\n**kwargs: options for optuna hyperparameter suggestions")]),e._v(" "),t("p",[e._v("Returns:")]),e._v(" "),t("p",[e._v("kwargs can be used to pass relevant arguments to")]),e._v(" "),t("ul",[t("li",[e._v("trial.suggest_float()")]),e._v(" "),t("li",[e._v("trial.suggest_int()")]),e._v(" "),t("li",[e._v("trial.suggest_categorical()")])]),e._v(" "),t("p",[e._v("For instance it can")]),e._v(" "),t("ul",[t("li",[e._v("add a low/high value if not existing for the hyperparameter\nor override it to narrow the search. (for float or int hyperparameters)")]),e._v(" "),t("li",[e._v("add a step or log argument (for float or int hyperparameters,\nsee optuna.trial.Trial.suggest_float())")]),e._v(" "),t("li",[e._v("override choices for categorical or enum parameters to narrow the search")])]),e._v(" "),t("h3",{attrs:{id:"suggest-hyperparameters-with-optuna"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#suggest-hyperparameters-with-optuna"}},[e._v("#")]),e._v(" suggest_hyperparameters_with_optuna "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"suggest_hyperparameters_with_optuna",sig:{params:[{name:"trial",annotation:"optuna.trial.Trial"},{name:"names",default:"None",annotation:"Optional[list[str]]"},{name:"kwargs_by_name",default:"None",annotation:"Optional[dict[str, dict[str, Any]]]"},{name:"fixed_hyperparameters",default:"None",annotation:"Optional[dict[str, Any]]"},{name:"prefix",default:"",annotation:"str"}],return:"dict[str, Any]"}}}),e._v(" "),t("p",[e._v("Suggest hyperparameters values during an Optuna trial.")]),e._v(" "),t("p",[e._v("Args:\ntrial: optuna trial during hyperparameters tuning\nnames: names of the hyperparameters to choose.\nBy default, all available hyperparameters will be suggested.\nIf "),t("code",[e._v("fixed_hyperparameters")]),e._v(" is provided, the corresponding names are removed from "),t("code",[e._v("names")]),e._v(".\nkwargs_by_name: options for optuna hyperparameter suggestions, by hyperparameter name\nfixed_hyperparameters: values of fixed hyperparameters, useful for suggesting subbrick hyperparameters,\nif the subbrick class is not suggested by this method, but already fixed.\nWill be added to the suggested hyperparameters.\nprefix: prefix to add to optuna corresponding parameters\n(useful for disambiguating hyperparameters from subsolvers in case of meta-solvers)")]),e._v(" "),t("p",[e._v("Returns:\nmapping between the hyperparameter name and its suggested value.\nIf the hyperparameter has an attribute "),t("code",[e._v("name_in_kwargs")]),e._v(", this is used as the key in the mapping\ninstead of the actual hyperparameter name.\nthe mapping is updated with "),t("code",[e._v("fixed_hyperparameters")]),e._v(".")]),e._v(" "),t("p",[e._v("kwargs_by_name[some_name] will be passed as **kwargs to suggest_hyperparameter_with_optuna(name=some_name)")]),e._v(" "),t("h3",{attrs:{id:"using-applicable-actions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#using-applicable-actions"}},[e._v("#")]),e._v(" using_applicable_actions "),t("Badge",{attrs:{text:"ApplicableActions",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"using_applicable_actions",sig:{params:[{name:"self"}]}}}),e._v(" "),t("p",[e._v("Tell if the solver is able to use applicable actions information.")]),e._v(" "),t("p",[e._v("For instance, action masking could be possible only if\nconsidered domain action space is enumerable for each agent.")]),e._v(" "),t("p",[e._v("The default implementation returns always True.")]),e._v(" "),t("h3",{attrs:{id:"check-domain-additional"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#check-domain-additional"}},[e._v("#")]),e._v(" _check_domain_additional "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_check_domain_additional",sig:{params:[{name:"domain",annotation:"Domain"}],return:"bool"}}}),e._v(" "),t("p",[e._v('Check whether the given domain is compliant with the specific requirements of this solver type (i.e. the\nones in addition to "domain requirements").')]),e._v(" "),t("p",[e._v("This is a helper function called by default from "),t("code",[e._v("Solver.check_domain()")]),e._v(". It focuses on specific checks, as\nopposed to taking also into account the domain requirements for the latter.")]),e._v(" "),t("h4",{attrs:{id:"parameters-8"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-8"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("domain")]),e._v(": The domain to check.")])]),e._v(" "),t("h4",{attrs:{id:"returns-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns-5"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),t("p",[e._v("True if the domain is compliant with the specific requirements of this solver type (False otherwise).")]),e._v(" "),t("h3",{attrs:{id:"cleanup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cleanup"}},[e._v("#")]),e._v(" _cleanup "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_cleanup",sig:{params:[{name:"self"}]}}}),e._v(" "),t("p",[e._v("Runs cleanup code here, or code to be executed at the exit of a\n'with' context statement.")]),e._v(" "),t("h3",{attrs:{id:"initialize"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#initialize"}},[e._v("#")]),e._v(" _initialize "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_initialize",sig:{params:[{name:"self"}]}}}),e._v(" "),t("p",[e._v("Runs long-lasting initialization code here.")]),e._v(" "),t("h3",{attrs:{id:"is-policy-defined-for-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#is-policy-defined-for-2"}},[e._v("#")]),e._v(" _is_policy_defined_for "),t("Badge",{attrs:{text:"Policies",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_is_policy_defined_for",sig:{params:[{name:"self"},{name:"observation",annotation:"D.T_agent[D.T_observation]"}],return:"bool"}}}),e._v(" "),t("p",[e._v("Check whether the solver's current policy is defined for the given observation.")]),e._v(" "),t("h4",{attrs:{id:"parameters-9"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-9"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("observation")]),e._v(": The observation to consider.")])]),e._v(" "),t("h4",{attrs:{id:"returns-6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns-6"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),t("p",[e._v("True if the policy is defined for the given observation memory (False otherwise).")]),e._v(" "),t("h3",{attrs:{id:"load-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#load-2"}},[e._v("#")]),e._v(" _load "),t("Badge",{attrs:{text:"Restorable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_load",sig:{params:[{name:"self"},{name:"path",annotation:"str"}]}}}),e._v(" "),t("p",[e._v("Restore the solver state from given path.")]),e._v(" "),t("h4",{attrs:{id:"parameters-10"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-10"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("path")]),e._v(": The path where the solver state was saved.")])]),e._v(" "),t("h3",{attrs:{id:"reset-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reset-2"}},[e._v("#")]),e._v(" _reset "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_reset",sig:{params:[{name:"self"}],return:"None"}}}),e._v(" "),t("p",[e._v("Reset whatever is needed on this solver before running a new episode.")]),e._v(" "),t("p",[e._v("This function does nothing by default but can be overridden if needed (e.g. to reset the hidden state of a LSTM\npolicy network, which carries information about past observations seen in the previous episode).")]),e._v(" "),t("h3",{attrs:{id:"sample-action-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sample-action-2"}},[e._v("#")]),e._v(" _sample_action "),t("Badge",{attrs:{text:"Policies",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_sample_action",sig:{params:[{name:"self"},{name:"observation",annotation:"D.T_agent[D.T_observation]"}],return:"D.T_agent[D.T_concurrency[D.T_event]]"}}}),e._v(" "),t("p",[e._v("Sample an action for the given observation (from the solver's current policy).")]),e._v(" "),t("h4",{attrs:{id:"parameters-11"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-11"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("observation")]),e._v(": The observation for which an action must be sampled.")])]),e._v(" "),t("h4",{attrs:{id:"returns-7"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns-7"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),t("p",[e._v("The sampled action.")]),e._v(" "),t("h3",{attrs:{id:"save-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#save-2"}},[e._v("#")]),e._v(" _save "),t("Badge",{attrs:{text:"Restorable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_save",sig:{params:[{name:"self"},{name:"path",annotation:"str"}],return:"None"}}}),e._v(" "),t("p",[e._v("Save the solver state to given path.")]),e._v(" "),t("h4",{attrs:{id:"parameters-12"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-12"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("path")]),e._v(": The path to store the saved state.")])]),e._v(" "),t("h3",{attrs:{id:"set-action-mask-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set-action-mask-2"}},[e._v("#")]),e._v(" _set_action_mask "),t("Badge",{attrs:{text:"Maskable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_set_action_mask",sig:{params:[{name:"self"},{name:"action_mask",annotation:"Optional[D.T_agent[Mask]]"}],return:"None"}}}),e._v(" "),t("p",[e._v("Set the action mask.")]),e._v(" "),t("p",[e._v("To be called during rollout before "),t("code",[e._v("self.sample_action()")]),e._v(", assuming that\n"),t("code",[e._v("self.sample_action()")]),e._v(" knows what to do with it.")]),e._v(" "),t("h3",{attrs:{id:"solve-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#solve-2"}},[e._v("#")]),e._v(" _solve "),t("Badge",{attrs:{text:"FromInitialState",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_solve",sig:{params:[{name:"self"}],return:"None"}}}),e._v(" "),t("p",[e._v("Run the solving process.")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),t("p",[e._v("The nature of the solutions produced here depends on other solver's characteristics like\n"),t("code",[e._v("policy")]),e._v(" and "),t("code",[e._v("assessibility")]),e._v(".")])]),e._v(" "),t("h2",{attrs:{id:"callbackwrapper"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#callbackwrapper"}},[e._v("#")]),e._v(" _CallbackWrapper")]),e._v(" "),t("p",[e._v("Wrapper to avoid surprises with lambda functions")]),e._v(" "),t("h3",{attrs:{id:"constructor-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#constructor-2"}},[e._v("#")]),e._v(" Constructor "),t("Badge",{attrs:{text:"_CallbackWrapper",type:"tip"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_CallbackWrapper",sig:{params:[{name:"callback",annotation:"Callable[[RayRLlib], bool]"}]}}}),e._v(" "),t("p",[e._v("Initialize self.  See help(type(self)) for accurate signature.")]),e._v(" "),t("h2",{attrs:{id:"solveearlystop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#solveearlystop"}},[e._v("#")]),e._v(" SolveEarlyStop")]),e._v(" "),t("p",[e._v("Exception raised if a callback tells to stop the solve process.")])],1)}),[],!1,null,null,null);a.default=s.exports}}]);