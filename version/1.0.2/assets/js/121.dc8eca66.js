(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{633:function(e,a,t){"use strict";t.r(a);var r=t(38),s=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"hub-solver-ray-rllib-ray-rllib"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hub-solver-ray-rllib-ray-rllib"}},[e._v("#")]),e._v(" hub.solver.ray_rllib.ray_rllib")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("Domain specification")]),e._v(" "),t("skdecide-summary")],1),e._v(" "),t("h2",{attrs:{id:"rayrllib"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rayrllib"}},[e._v("#")]),e._v(" RayRLlib")]),e._v(" "),t("p",[e._v("This class wraps a Ray RLlib solver (ray[rllib]) as a scikit-decide solver.")]),e._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[e._v("WARNING")]),e._v(" "),t("p",[e._v("Using this class requires Ray RLlib to be installed.")])]),e._v(" "),t("h3",{attrs:{id:"constructor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[e._v("#")]),e._v(" Constructor "),t("Badge",{attrs:{text:"RayRLlib",type:"tip"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"RayRLlib",sig:{params:[{name:"domain_factory",annotation:"Callable[[], Domain]"},{name:"algo_class",annotation:"type[Algorithm]"},{name:"train_iterations",annotation:"int"},{name:"config",default:"None",annotation:"Optional[AlgorithmConfig]"},{name:"policy_configs",default:"None",annotation:"Optional[dict[str, dict]]"},{name:"policy_mapping_fn",default:"None",annotation:"Optional[Callable[[str, Optional['EpisodeV2'], Optional['RolloutWorker']], str]]"},{name:"action_embed_sizes",default:"None",annotation:"Optional[dict[str, int]]"},{name:"config_kwargs",default:"None",annotation:"Optional[dict[str, Any]]"},{name:"callback",default:"<lambda function>",annotation:"Callable[[RayRLlib], bool]"},{name:"**kwargs"}],return:"None"}}}),e._v(" "),t("p",[e._v("Initialize Ray RLlib.")]),e._v(" "),t("h4",{attrs:{id:"parameters"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("domain_factory")]),e._v(": A callable with no argument returning the domain to solve (can be a mere domain class).\nThe resulting domain will be auto-cast to the level expected by the solver.")]),e._v(" "),t("li",[t("strong",[e._v("algo_class")]),e._v(": The class of Ray RLlib trainer/agent to wrap.")]),e._v(" "),t("li",[t("strong",[e._v("train_iterations")]),e._v(": The number of iterations to call the trainer's train() method.")]),e._v(" "),t("li",[t("strong",[e._v("config")]),e._v(": The configuration dictionary for the trainer.")]),e._v(" "),t("li",[t("strong",[e._v("policy_configs")]),e._v(": The mapping from policy id (str) to additional config (dict) (leave default for single policy).")]),e._v(" "),t("li",[t("strong",[e._v("policy_mapping_fn")]),e._v(": The function mapping agent ids to policy ids (leave default for single policy).")]),e._v(" "),t("li",[t("strong",[e._v("action_embed_sizes")]),e._v(": The mapping from policy id (str) to action embedding size (only used with domains filtering allowed actions per state, default to 2)")]),e._v(" "),t("li",[t("strong",[e._v("config_kwargs")]),e._v(": keyword arguments for the "),t("code",[e._v("AlgorithmConfigKwargs")]),e._v(" class used to update programmatically the algorithm config.\nWill be used by hyerparameters tuners like optuna. Should probably not be used directly by the user,\nwho could rather directly specify the correct "),t("code",[e._v("config")]),e._v(".")]),e._v(" "),t("li",[t("strong",[e._v("callback")]),e._v(": function called at each solver iteration.\nIf returning true, the solve process stops and exit the current train iteration.\nHowever, if train_iterations > 1, another train loop will be entered after that.\n(One can code its callback in such a way that further training loop are stopped directly after that.)")])]),e._v(" "),t("h3",{attrs:{id:"autocast"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#autocast"}},[e._v("#")]),e._v(" autocast "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"autocast",sig:{params:[{name:"self"},{name:"domain_cls",default:"None",annotation:"Optional[type[Domain]]"}],return:"None"}}}),e._v(" "),t("p",[e._v("Autocast itself to the level corresponding to the given domain class.")]),e._v(" "),t("h4",{attrs:{id:"parameters-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-2"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("domain_cls")]),e._v(": the domain class to which level the solver needs to autocast itself.\nBy default, use the original domain factory passed to its constructor.")])]),e._v(" "),t("h3",{attrs:{id:"check-domain"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#check-domain"}},[e._v("#")]),e._v(" check_domain "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"check_domain",sig:{params:[{name:"domain",annotation:"Domain"}],return:"bool"}}}),e._v(" "),t("p",[e._v("Check whether a domain is compliant with this solver type.")]),e._v(" "),t("p",[e._v("By default, "),t("code",[e._v("Solver.check_domain()")]),e._v(" provides some boilerplate code and internally\ncalls "),t("code",[e._v("Solver._check_domain_additional()")]),e._v(' (which returns True by default but can be overridden  to define\nspecific checks in addition to the "domain requirements"). The boilerplate code automatically checks whether all\ndomain requirements are met.')]),e._v(" "),t("h4",{attrs:{id:"parameters-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-3"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("domain")]),e._v(": The domain to check.")])]),e._v(" "),t("h4",{attrs:{id:"returns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),t("p",[e._v("True if the domain is compliant with the solver type (False otherwise).")]),e._v(" "),t("h3",{attrs:{id:"complete-with-default-hyperparameters"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#complete-with-default-hyperparameters"}},[e._v("#")]),e._v(" complete_with_default_hyperparameters "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"complete_with_default_hyperparameters",sig:{params:[{name:"kwargs",annotation:"dict[str, Any]"},{name:"names",default:"None",annotation:"Optional[list[str]]"}]}}}),e._v(" "),t("p",[e._v("Add missing hyperparameters to kwargs by using default values")]),e._v(" "),t("p",[e._v("Args:\nkwargs: keyword arguments to complete (e.g. for "),t("code",[e._v("__init__")]),e._v(", "),t("code",[e._v("init_model")]),e._v(", or "),t("code",[e._v("solve")]),e._v(")\nnames: names of the hyperparameters to add if missing.\nBy default, all available hyperparameters.")]),e._v(" "),t("p",[e._v("Returns:\na new dictionary, completion of kwargs")]),e._v(" "),t("h3",{attrs:{id:"copy-and-update-hyperparameters"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#copy-and-update-hyperparameters"}},[e._v("#")]),e._v(" copy_and_update_hyperparameters "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"copy_and_update_hyperparameters",sig:{params:[{name:"names",default:"None",annotation:"Optional[list[str]]"},{name:"**kwargs_by_name",annotation:"dict[str, Any]"}],return:"list[Hyperparameter]"}}}),e._v(" "),t("p",[e._v("Copy hyperparameters definition of this class and update them with specified kwargs.")]),e._v(" "),t("p",[e._v("This is useful to define hyperparameters for a child class\nfor which only choices of the hyperparameter change for instance.")]),e._v(" "),t("p",[e._v("Args:\nnames: names of hyperparameters to copy. Default to all.\n**kwargs_by_name: for each hyperparameter specified by its name,\nthe attributes to update. If a given hyperparameter name is not specified,\nthe hyperparameter is copied without further update.")]),e._v(" "),t("p",[e._v("Returns:")]),e._v(" "),t("h3",{attrs:{id:"forget-callback"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#forget-callback"}},[e._v("#")]),e._v(" forget_callback "),t("Badge",{attrs:{text:"RayRLlib",type:"tip"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"forget_callback",sig:{params:[{name:"self"}]}}}),e._v(" "),t("p",[e._v("Forget about actual callback to avoid serializing issues.")]),e._v(" "),t("h3",{attrs:{id:"get-default-hyperparameters"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-default-hyperparameters"}},[e._v("#")]),e._v(" get_default_hyperparameters "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"get_default_hyperparameters",sig:{params:[{name:"names",default:"None",annotation:"Optional[list[str]]"}],return:"dict[str, Any]"}}}),e._v(" "),t("p",[e._v("Get hyperparameters default values.")]),e._v(" "),t("p",[e._v("Args:\nnames: names of the hyperparameters to choose.\nBy default, all available hyperparameters will be suggested.")]),e._v(" "),t("p",[e._v("Returns:\na mapping between hyperparameter's name_in_kwargs and its default value (None if not specified)")]),e._v(" "),t("h3",{attrs:{id:"get-domain-requirements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-domain-requirements"}},[e._v("#")]),e._v(" get_domain_requirements "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"get_domain_requirements",sig:{params:[],return:"list[type]"}}}),e._v(" "),t("p",[e._v("Get domain requirements for this solver class to be applicable.")]),e._v(" "),t("p",[e._v("Domain requirements are classes from the "),t("code",[e._v("skdecide.builders.domain")]),e._v(" package that the domain needs to inherit from.")]),e._v(" "),t("h4",{attrs:{id:"returns-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns-2"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),t("p",[e._v("A list of classes to inherit from.")]),e._v(" "),t("h3",{attrs:{id:"get-hyperparameter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-hyperparameter"}},[e._v("#")]),e._v(" get_hyperparameter "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"get_hyperparameter",sig:{params:[{name:"name",annotation:"str"}],return:"Hyperparameter"}}}),e._v(" "),t("p",[e._v("Get hyperparameter from given name.")]),e._v(" "),t("h3",{attrs:{id:"get-hyperparameters-by-name"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-hyperparameters-by-name"}},[e._v("#")]),e._v(" get_hyperparameters_by_name "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"get_hyperparameters_by_name",sig:{params:[],return:"dict[str, Hyperparameter]"}}}),e._v(" "),t("p",[e._v("Mapping from name to corresponding hyperparameter.")]),e._v(" "),t("h3",{attrs:{id:"get-hyperparameters-names"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-hyperparameters-names"}},[e._v("#")]),e._v(" get_hyperparameters_names "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"get_hyperparameters_names",sig:{params:[],return:"list[str]"}}}),e._v(" "),t("p",[e._v("List of hyperparameters names.")]),e._v(" "),t("h3",{attrs:{id:"get-policy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-policy"}},[e._v("#")]),e._v(" get_policy "),t("Badge",{attrs:{text:"RayRLlib",type:"tip"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"get_policy",sig:{params:[{name:"self"}],return:"dict[str, Policy]"}}}),e._v(" "),t("p",[e._v("Return the computed policy.")]),e._v(" "),t("h3",{attrs:{id:"is-policy-defined-for"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#is-policy-defined-for"}},[e._v("#")]),e._v(" is_policy_defined_for "),t("Badge",{attrs:{text:"Policies",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"is_policy_defined_for",sig:{params:[{name:"self"},{name:"observation",annotation:"D.T_agent[D.T_observation]"}],return:"bool"}}}),e._v(" "),t("p",[e._v("Check whether the solver's current policy is defined for the given observation.")]),e._v(" "),t("h4",{attrs:{id:"parameters-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-4"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("observation")]),e._v(": The observation to consider.")])]),e._v(" "),t("h4",{attrs:{id:"returns-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns-3"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),t("p",[e._v("True if the policy is defined for the given observation memory (False otherwise).")]),e._v(" "),t("h3",{attrs:{id:"load"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#load"}},[e._v("#")]),e._v(" load "),t("Badge",{attrs:{text:"Restorable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"load",sig:{params:[{name:"self"},{name:"path",annotation:"str"}],return:"None"}}}),e._v(" "),t("p",[e._v("Restore the solver state from given path.")]),e._v(" "),t("p",[e._v("After calling self._load(), autocast itself so that rollout methods apply\nto the domain original characteristics.")]),e._v(" "),t("h4",{attrs:{id:"parameters-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-5"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("path")]),e._v(": The path where the solver state was saved.")])]),e._v(" "),t("h3",{attrs:{id:"reset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reset"}},[e._v("#")]),e._v(" reset "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"reset",sig:{params:[{name:"self"}],return:"None"}}}),e._v(" "),t("p",[e._v("Reset whatever is needed on this solver before running a new episode.")]),e._v(" "),t("p",[e._v("This function does nothing by default but can be overridden if needed (e.g. to reset the hidden state of a LSTM\npolicy network, which carries information about past observations seen in the previous episode).")]),e._v(" "),t("h3",{attrs:{id:"sample-action"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sample-action"}},[e._v("#")]),e._v(" sample_action "),t("Badge",{attrs:{text:"Policies",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"sample_action",sig:{params:[{name:"self"},{name:"observation",annotation:"D.T_agent[D.T_observation]"}],return:"D.T_agent[D.T_concurrency[D.T_event]]"}}}),e._v(" "),t("p",[e._v("Sample an action for the given observation (from the solver's current policy).")]),e._v(" "),t("h4",{attrs:{id:"parameters-6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-6"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("observation")]),e._v(": The observation for which an action must be sampled.")])]),e._v(" "),t("h4",{attrs:{id:"returns-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns-4"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),t("p",[e._v("The sampled action.")]),e._v(" "),t("h3",{attrs:{id:"save"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#save"}},[e._v("#")]),e._v(" save "),t("Badge",{attrs:{text:"Restorable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"save",sig:{params:[{name:"self"},{name:"path",annotation:"str"}],return:"None"}}}),e._v(" "),t("p",[e._v("Save the solver state to given path.")]),e._v(" "),t("h4",{attrs:{id:"parameters-7"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-7"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("path")]),e._v(": The path to store the saved state.")])]),e._v(" "),t("h3",{attrs:{id:"set-callback"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set-callback"}},[e._v("#")]),e._v(" set_callback "),t("Badge",{attrs:{text:"RayRLlib",type:"tip"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"set_callback",sig:{params:[{name:"self"}]}}}),e._v(" "),t("p",[e._v("Set back callback.")]),e._v(" "),t("p",[e._v("Useful to do it after serializing/deserializing because of potential issues with")]),e._v(" "),t("ul",[t("li",[e._v("lambda functions")]),e._v(" "),t("li",[e._v("dynamic classes")])]),e._v(" "),t("h3",{attrs:{id:"solve"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#solve"}},[e._v("#")]),e._v(" solve "),t("Badge",{attrs:{text:"FromInitialState",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"solve",sig:{params:[{name:"self"}],return:"None"}}}),e._v(" "),t("p",[e._v("Run the solving process.")]),e._v(" "),t("p",[e._v("After solving by calling self._solve(), autocast itself so that rollout methods apply\nto the domain original characteristics.")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),t("p",[e._v("The nature of the solutions produced here depends on other solver's characteristics like\n"),t("code",[e._v("policy")]),e._v(" and "),t("code",[e._v("assessibility")]),e._v(".")])]),e._v(" "),t("h3",{attrs:{id:"suggest-hyperparameter-with-optuna"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#suggest-hyperparameter-with-optuna"}},[e._v("#")]),e._v(" suggest_hyperparameter_with_optuna "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"suggest_hyperparameter_with_optuna",sig:{params:[{name:"trial",annotation:"optuna.trial.Trial"},{name:"name",annotation:"str"},{name:"prefix",default:"",annotation:"str"},{name:"**kwargs"}],return:"Any"}}}),e._v(" "),t("p",[e._v("Suggest hyperparameter value during an Optuna trial.")]),e._v(" "),t("p",[e._v("This can be used during Optuna hyperparameters tuning.")]),e._v(" "),t("p",[e._v("Args:\ntrial: optuna trial during hyperparameters tuning\nname: name of the hyperparameter to choose\nprefix: prefix to add to optuna corresponding parameter name\n(useful for disambiguating hyperparameters from subsolvers in case of meta-solvers)\n**kwargs: options for optuna hyperparameter suggestions")]),e._v(" "),t("p",[e._v("Returns:")]),e._v(" "),t("p",[e._v("kwargs can be used to pass relevant arguments to")]),e._v(" "),t("ul",[t("li",[e._v("trial.suggest_float()")]),e._v(" "),t("li",[e._v("trial.suggest_int()")]),e._v(" "),t("li",[e._v("trial.suggest_categorical()")])]),e._v(" "),t("p",[e._v("For instance it can")]),e._v(" "),t("ul",[t("li",[e._v("add a low/high value if not existing for the hyperparameter\nor override it to narrow the search. (for float or int hyperparameters)")]),e._v(" "),t("li",[e._v("add a step or log argument (for float or int hyperparameters,\nsee optuna.trial.Trial.suggest_float())")]),e._v(" "),t("li",[e._v("override choices for categorical or enum parameters to narrow the search")])]),e._v(" "),t("h3",{attrs:{id:"suggest-hyperparameters-with-optuna"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#suggest-hyperparameters-with-optuna"}},[e._v("#")]),e._v(" suggest_hyperparameters_with_optuna "),t("Badge",{attrs:{text:"Hyperparametrizable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"suggest_hyperparameters_with_optuna",sig:{params:[{name:"trial",annotation:"optuna.trial.Trial"},{name:"names",default:"None",annotation:"Optional[list[str]]"},{name:"kwargs_by_name",default:"None",annotation:"Optional[dict[str, dict[str, Any]]]"},{name:"fixed_hyperparameters",default:"None",annotation:"Optional[dict[str, Any]]"},{name:"prefix",default:"",annotation:"str"}],return:"dict[str, Any]"}}}),e._v(" "),t("p",[e._v("Suggest hyperparameters values during an Optuna trial.")]),e._v(" "),t("p",[e._v("Args:\ntrial: optuna trial during hyperparameters tuning\nnames: names of the hyperparameters to choose.\nBy default, all available hyperparameters will be suggested.\nIf "),t("code",[e._v("fixed_hyperparameters")]),e._v(" is provided, the corresponding names are removed from "),t("code",[e._v("names")]),e._v(".\nkwargs_by_name: options for optuna hyperparameter suggestions, by hyperparameter name\nfixed_hyperparameters: values of fixed hyperparameters, useful for suggesting subbrick hyperparameters,\nif the subbrick class is not suggested by this method, but already fixed.\nWill be added to the suggested hyperparameters.\nprefix: prefix to add to optuna corresponding parameters\n(useful for disambiguating hyperparameters from subsolvers in case of meta-solvers)")]),e._v(" "),t("p",[e._v("Returns:\nmapping between the hyperparameter name and its suggested value.\nIf the hyperparameter has an attribute "),t("code",[e._v("name_in_kwargs")]),e._v(", this is used as the key in the mapping\ninstead of the actual hyperparameter name.\nthe mapping is updated with "),t("code",[e._v("fixed_hyperparameters")]),e._v(".")]),e._v(" "),t("p",[e._v("kwargs_by_name[some_name] will be passed as **kwargs to suggest_hyperparameter_with_optuna(name=some_name)")]),e._v(" "),t("h3",{attrs:{id:"check-domain-additional"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#check-domain-additional"}},[e._v("#")]),e._v(" _check_domain_additional "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_check_domain_additional",sig:{params:[{name:"domain",annotation:"Domain"}],return:"bool"}}}),e._v(" "),t("p",[e._v('Check whether the given domain is compliant with the specific requirements of this solver type (i.e. the\nones in addition to "domain requirements").')]),e._v(" "),t("p",[e._v("This is a helper function called by default from "),t("code",[e._v("Solver.check_domain()")]),e._v(". It focuses on specific checks, as\nopposed to taking also into account the domain requirements for the latter.")]),e._v(" "),t("h4",{attrs:{id:"parameters-8"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-8"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("domain")]),e._v(": The domain to check.")])]),e._v(" "),t("h4",{attrs:{id:"returns-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns-5"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),t("p",[e._v("True if the domain is compliant with the specific requirements of this solver type (False otherwise).")]),e._v(" "),t("h3",{attrs:{id:"cleanup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cleanup"}},[e._v("#")]),e._v(" _cleanup "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_cleanup",sig:{params:[{name:"self"}]}}}),e._v(" "),t("p",[e._v("Runs cleanup code here, or code to be executed at the exit of a\n'with' context statement.")]),e._v(" "),t("h3",{attrs:{id:"initialize"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#initialize"}},[e._v("#")]),e._v(" _initialize "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_initialize",sig:{params:[{name:"self"}]}}}),e._v(" "),t("p",[e._v("Runs long-lasting initialization code here.")]),e._v(" "),t("h3",{attrs:{id:"is-policy-defined-for-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#is-policy-defined-for-2"}},[e._v("#")]),e._v(" _is_policy_defined_for "),t("Badge",{attrs:{text:"Policies",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_is_policy_defined_for",sig:{params:[{name:"self"},{name:"observation",annotation:"D.T_agent[D.T_observation]"}],return:"bool"}}}),e._v(" "),t("p",[e._v("Check whether the solver's current policy is defined for the given observation.")]),e._v(" "),t("h4",{attrs:{id:"parameters-9"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-9"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("observation")]),e._v(": The observation to consider.")])]),e._v(" "),t("h4",{attrs:{id:"returns-6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns-6"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),t("p",[e._v("True if the policy is defined for the given observation memory (False otherwise).")]),e._v(" "),t("h3",{attrs:{id:"load-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#load-2"}},[e._v("#")]),e._v(" _load "),t("Badge",{attrs:{text:"Restorable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_load",sig:{params:[{name:"self"},{name:"path",annotation:"str"}]}}}),e._v(" "),t("p",[e._v("Restore the solver state from given path.")]),e._v(" "),t("h4",{attrs:{id:"parameters-10"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-10"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("path")]),e._v(": The path where the solver state was saved.")])]),e._v(" "),t("h3",{attrs:{id:"reset-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reset-2"}},[e._v("#")]),e._v(" _reset "),t("Badge",{attrs:{text:"Solver",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_reset",sig:{params:[{name:"self"}],return:"None"}}}),e._v(" "),t("p",[e._v("Reset whatever is needed on this solver before running a new episode.")]),e._v(" "),t("p",[e._v("This function does nothing by default but can be overridden if needed (e.g. to reset the hidden state of a LSTM\npolicy network, which carries information about past observations seen in the previous episode).")]),e._v(" "),t("h3",{attrs:{id:"sample-action-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sample-action-2"}},[e._v("#")]),e._v(" _sample_action "),t("Badge",{attrs:{text:"Policies",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_sample_action",sig:{params:[{name:"self"},{name:"observation",annotation:"D.T_agent[D.T_observation]"}],return:"D.T_agent[D.T_concurrency[D.T_event]]"}}}),e._v(" "),t("p",[e._v("Sample an action for the given observation (from the solver's current policy).")]),e._v(" "),t("h4",{attrs:{id:"parameters-11"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-11"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("observation")]),e._v(": The observation for which an action must be sampled.")])]),e._v(" "),t("h4",{attrs:{id:"returns-7"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns-7"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),t("p",[e._v("The sampled action.")]),e._v(" "),t("h3",{attrs:{id:"save-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#save-2"}},[e._v("#")]),e._v(" _save "),t("Badge",{attrs:{text:"Restorable",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_save",sig:{params:[{name:"self"},{name:"path",annotation:"str"}],return:"None"}}}),e._v(" "),t("p",[e._v("Save the solver state to given path.")]),e._v(" "),t("h4",{attrs:{id:"parameters-12"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters-12"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("path")]),e._v(": The path to store the saved state.")])]),e._v(" "),t("h3",{attrs:{id:"solve-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#solve-2"}},[e._v("#")]),e._v(" _solve "),t("Badge",{attrs:{text:"FromInitialState",type:"warn"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_solve",sig:{params:[{name:"self"}],return:"None"}}}),e._v(" "),t("p",[e._v("Run the solving process.")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),t("p",[e._v("The nature of the solutions produced here depends on other solver's characteristics like\n"),t("code",[e._v("policy")]),e._v(" and "),t("code",[e._v("assessibility")]),e._v(".")])]),e._v(" "),t("h2",{attrs:{id:"callbackwrapper"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#callbackwrapper"}},[e._v("#")]),e._v(" _CallbackWrapper")]),e._v(" "),t("p",[e._v("Wrapper to avoid surprises with lambda functions")]),e._v(" "),t("h3",{attrs:{id:"constructor-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#constructor-2"}},[e._v("#")]),e._v(" Constructor "),t("Badge",{attrs:{text:"_CallbackWrapper",type:"tip"}})],1),e._v(" "),t("skdecide-signature",{attrs:{name:"_CallbackWrapper",sig:{params:[{name:"callback",annotation:"Callable[[RayRLlib], bool]"}]}}}),e._v(" "),t("p",[e._v("Initialize self.  See help(type(self)) for accurate signature.")]),e._v(" "),t("h2",{attrs:{id:"solveearlystop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#solveearlystop"}},[e._v("#")]),e._v(" SolveEarlyStop")]),e._v(" "),t("p",[e._v("Exception raised if a callback tells to stop the solve process.")])],1)}),[],!1,null,null,null);a.default=s.exports}}]);