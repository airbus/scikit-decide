(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{543:function(e,t,a){"use strict";a.r(t);var s=a(38),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"builders-domain-events"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#builders-domain-events"}},[e._v("#")]),e._v(" builders.domain.events")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("Domain specification")]),e._v(" "),a("skdecide-summary")],1),e._v(" "),a("h2",{attrs:{id:"events"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#events"}},[e._v("#")]),e._v(" Events")]),e._v(" "),a("p",[e._v("A domain must inherit this class if it handles events (controllable or not not by the agents).")]),e._v(" "),a("h3",{attrs:{id:"get-action-space"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-action-space"}},[e._v("#")]),e._v(" get_action_space "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"get_action_space",sig:{params:[{name:"self"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the (cached) domain action space (finite or infinite set).")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events.get_action_space()")]),e._v(" internally calls "),a("code",[e._v("Events._get_action_space_()")]),e._v(" the first time and\nautomatically caches its value to make future calls more efficient (since the action space is assumed to be\nconstant).")]),e._v(" "),a("h4",{attrs:{id:"returns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The action space.")]),e._v(" "),a("h3",{attrs:{id:"get-applicable-actions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-applicable-actions"}},[e._v("#")]),e._v(" get_applicable_actions "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"get_applicable_actions",sig:{params:[{name:"self"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of applicable actions in the given memory (state or history), or in\nthe internal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events.get_applicable_actions()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._get_applicable_actions()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute\ninstead of the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-2"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of applicable actions.")]),e._v(" "),a("h3",{attrs:{id:"get-enabled-events"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-enabled-events"}},[e._v("#")]),e._v(" get_enabled_events "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"get_enabled_events",sig:{params:[{name:"self"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"Space[D.T_event]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of enabled uncontrollable events in the given memory (state or\nhistory), or in the internal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events.get_enabled_events()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._get_enabled_events()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute instead of\nthe memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-2"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-3"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of enabled events.")]),e._v(" "),a("h3",{attrs:{id:"is-action"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-action"}},[e._v("#")]),e._v(" is_action "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"is_action",sig:{params:[{name:"self"},{name:"event",annotation:"D.T_event"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an event is an action (i.e. a controllable event for the agents).")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("By default, this function is implemented using the "),a("code",[e._v("skdecide.core.Space.contains()")]),e._v(" function on the domain\naction space provided by "),a("code",[e._v("Events.get_action_space()")]),e._v(", but it can be overridden for faster implementations.")])]),e._v(" "),a("h4",{attrs:{id:"parameters-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-3"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("event")]),e._v(": The event to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-4"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the event is an action (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-applicable-action"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-applicable-action"}},[e._v("#")]),e._v(" is_applicable_action "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"is_applicable_action",sig:{params:[{name:"self"},{name:"action",annotation:"D.T_agent[D.T_event]"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an action is applicable in the given memory (state or history), or in the internal one if\nomitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events.is_applicable_action()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._is_applicable_action()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute instead\nof the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-4"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-5"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the action is applicable (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-enabled-event"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-enabled-event"}},[e._v("#")]),e._v(" is_enabled_event "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"is_enabled_event",sig:{params:[{name:"self"},{name:"event",annotation:"D.T_event"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an uncontrollable event is enabled in the given memory (state or history), or in the\ninternal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events.is_enabled_event()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._is_enabled_event()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute instead of\nthe memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-5"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-6"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the event is enabled (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"get-action-space-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-action-space-2"}},[e._v("#")]),e._v(" _get_action_space "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_action_space",sig:{params:[{name:"self"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the (cached) domain action space (finite or infinite set).")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events._get_action_space()")]),e._v(" internally calls "),a("code",[e._v("Events._get_action_space_()")]),e._v(" the first time and\nautomatically caches its value to make future calls more efficient (since the action space is assumed to be\nconstant).")]),e._v(" "),a("h4",{attrs:{id:"returns-7"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-7"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The action space.")]),e._v(" "),a("h3",{attrs:{id:"get-action-space-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-action-space-3"}},[e._v("#")]),e._v(" _get_action_space_ "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_action_space_",sig:{params:[{name:"self"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the domain action space (finite or infinite set).")]),e._v(" "),a("p",[e._v("This is a helper function called by default from "),a("code",[e._v("Events._get_action_space()")]),e._v(", the difference being that the\nresult is not cached here.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("The underscore at the end of this function's name is a convention to remind that its result should be\nconstant.")])]),e._v(" "),a("h4",{attrs:{id:"returns-8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-8"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The action space.")]),e._v(" "),a("h3",{attrs:{id:"get-applicable-actions-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-applicable-actions-2"}},[e._v("#")]),e._v(" _get_applicable_actions "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_applicable_actions",sig:{params:[{name:"self"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of applicable actions in the given memory (state or history), or in\nthe internal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events._get_applicable_actions()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._get_applicable_actions_from()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute\ninstead of the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-6"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-9"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-9"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of applicable actions.")]),e._v(" "),a("h3",{attrs:{id:"get-applicable-actions-from"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-applicable-actions-from"}},[e._v("#")]),e._v(" _get_applicable_actions_from "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_applicable_actions_from",sig:{params:[{name:"self"},{name:"memory",annotation:"D.T_memory[D.T_state]"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of applicable actions in the given memory (state or history).")]),e._v(" "),a("p",[e._v("This is a helper function called by default from "),a("code",[e._v("Events._get_applicable_actions()")]),e._v(", the difference being that\nthe memory parameter is mandatory here.")]),e._v(" "),a("h4",{attrs:{id:"parameters-7"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-7"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-10"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-10"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of applicable actions.")]),e._v(" "),a("h3",{attrs:{id:"get-enabled-events-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-enabled-events-2"}},[e._v("#")]),e._v(" _get_enabled_events "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_enabled_events",sig:{params:[{name:"self"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"Space[D.T_event]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of enabled uncontrollable events in the given memory (state or\nhistory), or in the internal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events._get_enabled_events()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._get_enabled_events_from()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute\ninstead of the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-8"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-11"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-11"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of enabled events.")]),e._v(" "),a("h3",{attrs:{id:"get-enabled-events-from"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-enabled-events-from"}},[e._v("#")]),e._v(" _get_enabled_events_from "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_enabled_events_from",sig:{params:[{name:"self"},{name:"memory",annotation:"D.T_memory[D.T_state]"}],return:"Space[D.T_event]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of enabled uncontrollable events in the given memory (state or\nhistory).")]),e._v(" "),a("p",[e._v("This is a helper function called by default from "),a("code",[e._v("Events._get_enabled_events()")]),e._v(", the difference being that the\nmemory parameter is mandatory here.")]),e._v(" "),a("h4",{attrs:{id:"parameters-9"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-9"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-12"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-12"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of enabled events.")]),e._v(" "),a("h3",{attrs:{id:"is-action-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-action-2"}},[e._v("#")]),e._v(" _is_action "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_is_action",sig:{params:[{name:"self"},{name:"event",annotation:"D.T_event"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an event is an action (i.e. a controllable event for the agents).")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("By default, this function is implemented using the "),a("code",[e._v("skdecide.core.Space.contains()")]),e._v(" function on the domain\naction space provided by "),a("code",[e._v("Events._get_action_space()")]),e._v(", but it can be overridden for faster implementations.")])]),e._v(" "),a("h4",{attrs:{id:"parameters-10"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-10"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("event")]),e._v(": The event to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-13"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-13"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the event is an action (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-applicable-action-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-applicable-action-2"}},[e._v("#")]),e._v(" _is_applicable_action "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_is_applicable_action",sig:{params:[{name:"self"},{name:"action",annotation:"D.T_agent[D.T_event]"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an action is applicable in the given memory (state or history), or in the internal one if\nomitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events._is_applicable_action()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._is_applicable_action_from()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute\ninstead of the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-11"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-11"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-14"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-14"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the action is applicable (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-applicable-action-from"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-applicable-action-from"}},[e._v("#")]),e._v(" _is_applicable_action_from "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_is_applicable_action_from",sig:{params:[{name:"self"},{name:"action",annotation:"D.T_agent[D.T_event]"},{name:"memory",annotation:"D.T_memory[D.T_state]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an action is applicable in the given memory (state or history).")]),e._v(" "),a("p",[e._v("This is a helper function called by default from "),a("code",[e._v("Events._is_applicable_action()")]),e._v(", the difference being that the\nmemory parameter is mandatory here.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("By default, this function is implemented using the "),a("code",[e._v("skdecide.core.Space.contains()")]),e._v(" function on the space of\napplicable actions provided by "),a("code",[e._v("Events._get_applicable_actions_from()")]),e._v(", but it can be overridden for faster\nimplementations.")])]),e._v(" "),a("h4",{attrs:{id:"parameters-12"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-12"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-15"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-15"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the action is applicable (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-enabled-event-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-enabled-event-2"}},[e._v("#")]),e._v(" _is_enabled_event "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_is_enabled_event",sig:{params:[{name:"self"},{name:"event",annotation:"D.T_event"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an uncontrollable event is enabled in the given memory (state or history), or in the\ninternal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events._is_enabled_event()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._is_enabled_event_from()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute instead\nof the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-13"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-13"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-16"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-16"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the event is enabled (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-enabled-event-from"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-enabled-event-from"}},[e._v("#")]),e._v(" _is_enabled_event_from "),a("Badge",{attrs:{text:"Events",type:"tip"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_is_enabled_event_from",sig:{params:[{name:"self"},{name:"event",annotation:"D.T_event"},{name:"memory",annotation:"D.T_memory[D.T_state]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an event is enabled in the given memory (state or history).")]),e._v(" "),a("p",[e._v("This is a helper function called by default from "),a("code",[e._v("Events._is_enabled_event()")]),e._v(", the difference being that the\nmemory parameter is mandatory here.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("By default, this function is implemented using the "),a("code",[e._v("skdecide.core.Space.contains()")]),e._v(" function on the space of\nenabled events provided by "),a("code",[e._v("Events._get_enabled_events_from()")]),e._v(", but it can be overridden for faster\nimplementations.")])]),e._v(" "),a("h4",{attrs:{id:"parameters-14"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-14"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-17"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-17"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the event is enabled (False otherwise).")]),e._v(" "),a("h2",{attrs:{id:"actions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#actions"}},[e._v("#")]),e._v(" Actions")]),e._v(" "),a("p",[e._v("A domain must inherit this class if it handles only actions (i.e. controllable events).")]),e._v(" "),a("h3",{attrs:{id:"get-action-space-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-action-space-4"}},[e._v("#")]),e._v(" get_action_space "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"get_action_space",sig:{params:[{name:"self"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the (cached) domain action space (finite or infinite set).")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events.get_action_space()")]),e._v(" internally calls "),a("code",[e._v("Events._get_action_space_()")]),e._v(" the first time and\nautomatically caches its value to make future calls more efficient (since the action space is assumed to be\nconstant).")]),e._v(" "),a("h4",{attrs:{id:"returns-18"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-18"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The action space.")]),e._v(" "),a("h3",{attrs:{id:"get-applicable-actions-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-applicable-actions-3"}},[e._v("#")]),e._v(" get_applicable_actions "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"get_applicable_actions",sig:{params:[{name:"self"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of applicable actions in the given memory (state or history), or in\nthe internal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events.get_applicable_actions()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._get_applicable_actions()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute\ninstead of the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-15"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-15"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-19"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-19"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of applicable actions.")]),e._v(" "),a("h3",{attrs:{id:"get-enabled-events-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-enabled-events-3"}},[e._v("#")]),e._v(" get_enabled_events "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"get_enabled_events",sig:{params:[{name:"self"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"Space[D.T_event]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of enabled uncontrollable events in the given memory (state or\nhistory), or in the internal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events.get_enabled_events()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._get_enabled_events()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute instead of\nthe memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-16"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-16"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-20"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-20"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of enabled events.")]),e._v(" "),a("h3",{attrs:{id:"is-action-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-action-3"}},[e._v("#")]),e._v(" is_action "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"is_action",sig:{params:[{name:"self"},{name:"event",annotation:"D.T_event"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an event is an action (i.e. a controllable event for the agents).")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("By default, this function is implemented using the "),a("code",[e._v("skdecide.core.Space.contains()")]),e._v(" function on the domain\naction space provided by "),a("code",[e._v("Events.get_action_space()")]),e._v(", but it can be overridden for faster implementations.")])]),e._v(" "),a("h4",{attrs:{id:"parameters-17"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-17"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("event")]),e._v(": The event to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-21"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-21"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the event is an action (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-applicable-action-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-applicable-action-3"}},[e._v("#")]),e._v(" is_applicable_action "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"is_applicable_action",sig:{params:[{name:"self"},{name:"action",annotation:"D.T_agent[D.T_event]"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an action is applicable in the given memory (state or history), or in the internal one if\nomitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events.is_applicable_action()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._is_applicable_action()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute instead\nof the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-18"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-18"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-22"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-22"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the action is applicable (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-enabled-event-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-enabled-event-3"}},[e._v("#")]),e._v(" is_enabled_event "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"is_enabled_event",sig:{params:[{name:"self"},{name:"event",annotation:"D.T_event"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an uncontrollable event is enabled in the given memory (state or history), or in the\ninternal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events.is_enabled_event()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._is_enabled_event()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute instead of\nthe memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-19"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-19"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-23"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-23"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the event is enabled (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"get-action-space-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-action-space-5"}},[e._v("#")]),e._v(" _get_action_space "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_action_space",sig:{params:[{name:"self"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the (cached) domain action space (finite or infinite set).")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events._get_action_space()")]),e._v(" internally calls "),a("code",[e._v("Events._get_action_space_()")]),e._v(" the first time and\nautomatically caches its value to make future calls more efficient (since the action space is assumed to be\nconstant).")]),e._v(" "),a("h4",{attrs:{id:"returns-24"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-24"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The action space.")]),e._v(" "),a("h3",{attrs:{id:"get-action-space-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-action-space-6"}},[e._v("#")]),e._v(" _get_action_space_ "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_action_space_",sig:{params:[{name:"self"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the domain action space (finite or infinite set).")]),e._v(" "),a("p",[e._v("This is a helper function called by default from "),a("code",[e._v("Events._get_action_space()")]),e._v(", the difference being that the\nresult is not cached here.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("The underscore at the end of this function's name is a convention to remind that its result should be\nconstant.")])]),e._v(" "),a("h4",{attrs:{id:"returns-25"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-25"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The action space.")]),e._v(" "),a("h3",{attrs:{id:"get-applicable-actions-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-applicable-actions-4"}},[e._v("#")]),e._v(" _get_applicable_actions "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_applicable_actions",sig:{params:[{name:"self"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of applicable actions in the given memory (state or history), or in\nthe internal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events._get_applicable_actions()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._get_applicable_actions_from()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute\ninstead of the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-20"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-20"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-26"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-26"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of applicable actions.")]),e._v(" "),a("h3",{attrs:{id:"get-applicable-actions-from-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-applicable-actions-from-2"}},[e._v("#")]),e._v(" _get_applicable_actions_from "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_applicable_actions_from",sig:{params:[{name:"self"},{name:"memory",annotation:"D.T_memory[D.T_state]"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of applicable actions in the given memory (state or history).")]),e._v(" "),a("p",[e._v("This is a helper function called by default from "),a("code",[e._v("Events._get_applicable_actions()")]),e._v(", the difference being that\nthe memory parameter is mandatory here.")]),e._v(" "),a("h4",{attrs:{id:"parameters-21"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-21"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-27"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-27"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of applicable actions.")]),e._v(" "),a("h3",{attrs:{id:"get-enabled-events-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-enabled-events-4"}},[e._v("#")]),e._v(" _get_enabled_events "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_enabled_events",sig:{params:[{name:"self"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"Space[D.T_event]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of enabled uncontrollable events in the given memory (state or\nhistory), or in the internal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events._get_enabled_events()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._get_enabled_events_from()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute\ninstead of the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-22"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-22"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-28"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-28"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of enabled events.")]),e._v(" "),a("h3",{attrs:{id:"get-enabled-events-from-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-enabled-events-from-2"}},[e._v("#")]),e._v(" _get_enabled_events_from "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_enabled_events_from",sig:{params:[{name:"self"},{name:"memory",annotation:"D.T_memory[D.T_state]"}],return:"Space[D.T_event]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of enabled uncontrollable events in the given memory (state or\nhistory).")]),e._v(" "),a("p",[e._v("This is a helper function called by default from "),a("code",[e._v("Events._get_enabled_events()")]),e._v(", the difference being that the\nmemory parameter is mandatory here.")]),e._v(" "),a("h4",{attrs:{id:"parameters-23"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-23"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-29"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-29"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of enabled events.")]),e._v(" "),a("h3",{attrs:{id:"is-action-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-action-4"}},[e._v("#")]),e._v(" _is_action "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_is_action",sig:{params:[{name:"self"},{name:"event",annotation:"D.T_event"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an event is an action (i.e. a controllable event for the agents).")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("By default, this function is implemented using the "),a("code",[e._v("skdecide.core.Space.contains()")]),e._v(" function on the domain\naction space provided by "),a("code",[e._v("Events._get_action_space()")]),e._v(", but it can be overridden for faster implementations.")])]),e._v(" "),a("h4",{attrs:{id:"parameters-24"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-24"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("event")]),e._v(": The event to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-30"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-30"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the event is an action (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-applicable-action-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-applicable-action-4"}},[e._v("#")]),e._v(" _is_applicable_action "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_is_applicable_action",sig:{params:[{name:"self"},{name:"action",annotation:"D.T_agent[D.T_event]"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an action is applicable in the given memory (state or history), or in the internal one if\nomitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events._is_applicable_action()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._is_applicable_action_from()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute\ninstead of the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-25"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-25"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-31"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-31"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the action is applicable (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-applicable-action-from-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-applicable-action-from-2"}},[e._v("#")]),e._v(" _is_applicable_action_from "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_is_applicable_action_from",sig:{params:[{name:"self"},{name:"action",annotation:"D.T_agent[D.T_event]"},{name:"memory",annotation:"D.T_memory[D.T_state]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an action is applicable in the given memory (state or history).")]),e._v(" "),a("p",[e._v("This is a helper function called by default from "),a("code",[e._v("Events._is_applicable_action()")]),e._v(", the difference being that the\nmemory parameter is mandatory here.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("By default, this function is implemented using the "),a("code",[e._v("skdecide.core.Space.contains()")]),e._v(" function on the space of\napplicable actions provided by "),a("code",[e._v("Events._get_applicable_actions_from()")]),e._v(", but it can be overridden for faster\nimplementations.")])]),e._v(" "),a("h4",{attrs:{id:"parameters-26"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-26"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-32"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-32"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the action is applicable (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-enabled-event-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-enabled-event-4"}},[e._v("#")]),e._v(" _is_enabled_event "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_is_enabled_event",sig:{params:[{name:"self"},{name:"event",annotation:"D.T_event"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an uncontrollable event is enabled in the given memory (state or history), or in the\ninternal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events._is_enabled_event()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._is_enabled_event_from()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute instead\nof the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-27"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-27"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-33"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-33"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the event is enabled (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-enabled-event-from-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-enabled-event-from-2"}},[e._v("#")]),e._v(" _is_enabled_event_from "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_is_enabled_event_from",sig:{params:[{name:"self"},{name:"event",annotation:"D.T_event"},{name:"memory",annotation:"D.T_memory[D.T_state]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an event is enabled in the given memory (state or history).")]),e._v(" "),a("p",[e._v("This is a helper function called by default from "),a("code",[e._v("Events._is_enabled_event()")]),e._v(", the difference being that the\nmemory parameter is mandatory here.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("By default, this function is implemented using the "),a("code",[e._v("skdecide.core.Space.contains()")]),e._v(" function on the space of\nenabled events provided by "),a("code",[e._v("Events._get_enabled_events_from()")]),e._v(", but it can be overridden for faster\nimplementations.")])]),e._v(" "),a("h4",{attrs:{id:"parameters-28"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-28"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-34"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-34"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the event is enabled (False otherwise).")]),e._v(" "),a("h2",{attrs:{id:"unrestrictedactions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unrestrictedactions"}},[e._v("#")]),e._v(" UnrestrictedActions")]),e._v(" "),a("p",[e._v("A domain must inherit this class if it handles only actions (i.e. controllable events), which are always all\napplicable.")]),e._v(" "),a("h3",{attrs:{id:"get-action-space-7"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-action-space-7"}},[e._v("#")]),e._v(" get_action_space "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"get_action_space",sig:{params:[{name:"self"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the (cached) domain action space (finite or infinite set).")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events.get_action_space()")]),e._v(" internally calls "),a("code",[e._v("Events._get_action_space_()")]),e._v(" the first time and\nautomatically caches its value to make future calls more efficient (since the action space is assumed to be\nconstant).")]),e._v(" "),a("h4",{attrs:{id:"returns-35"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-35"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The action space.")]),e._v(" "),a("h3",{attrs:{id:"get-applicable-actions-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-applicable-actions-5"}},[e._v("#")]),e._v(" get_applicable_actions "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"get_applicable_actions",sig:{params:[{name:"self"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of applicable actions in the given memory (state or history), or in\nthe internal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events.get_applicable_actions()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._get_applicable_actions()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute\ninstead of the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-29"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-29"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-36"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-36"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of applicable actions.")]),e._v(" "),a("h3",{attrs:{id:"get-enabled-events-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-enabled-events-5"}},[e._v("#")]),e._v(" get_enabled_events "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"get_enabled_events",sig:{params:[{name:"self"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"Space[D.T_event]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of enabled uncontrollable events in the given memory (state or\nhistory), or in the internal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events.get_enabled_events()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._get_enabled_events()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute instead of\nthe memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-30"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-30"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-37"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-37"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of enabled events.")]),e._v(" "),a("h3",{attrs:{id:"is-action-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-action-5"}},[e._v("#")]),e._v(" is_action "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"is_action",sig:{params:[{name:"self"},{name:"event",annotation:"D.T_event"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an event is an action (i.e. a controllable event for the agents).")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("By default, this function is implemented using the "),a("code",[e._v("skdecide.core.Space.contains()")]),e._v(" function on the domain\naction space provided by "),a("code",[e._v("Events.get_action_space()")]),e._v(", but it can be overridden for faster implementations.")])]),e._v(" "),a("h4",{attrs:{id:"parameters-31"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-31"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("event")]),e._v(": The event to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-38"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-38"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the event is an action (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-applicable-action-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-applicable-action-5"}},[e._v("#")]),e._v(" is_applicable_action "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"is_applicable_action",sig:{params:[{name:"self"},{name:"action",annotation:"D.T_agent[D.T_event]"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an action is applicable in the given memory (state or history), or in the internal one if\nomitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events.is_applicable_action()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._is_applicable_action()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute instead\nof the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-32"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-32"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-39"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-39"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the action is applicable (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-enabled-event-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-enabled-event-5"}},[e._v("#")]),e._v(" is_enabled_event "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"is_enabled_event",sig:{params:[{name:"self"},{name:"event",annotation:"D.T_event"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an uncontrollable event is enabled in the given memory (state or history), or in the\ninternal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events.is_enabled_event()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._is_enabled_event()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute instead of\nthe memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-33"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-33"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-40"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-40"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the event is enabled (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"get-action-space-8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-action-space-8"}},[e._v("#")]),e._v(" _get_action_space "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_action_space",sig:{params:[{name:"self"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the (cached) domain action space (finite or infinite set).")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events._get_action_space()")]),e._v(" internally calls "),a("code",[e._v("Events._get_action_space_()")]),e._v(" the first time and\nautomatically caches its value to make future calls more efficient (since the action space is assumed to be\nconstant).")]),e._v(" "),a("h4",{attrs:{id:"returns-41"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-41"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The action space.")]),e._v(" "),a("h3",{attrs:{id:"get-action-space-9"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-action-space-9"}},[e._v("#")]),e._v(" _get_action_space_ "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_action_space_",sig:{params:[{name:"self"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the domain action space (finite or infinite set).")]),e._v(" "),a("p",[e._v("This is a helper function called by default from "),a("code",[e._v("Events._get_action_space()")]),e._v(", the difference being that the\nresult is not cached here.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("The underscore at the end of this function's name is a convention to remind that its result should be\nconstant.")])]),e._v(" "),a("h4",{attrs:{id:"returns-42"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-42"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The action space.")]),e._v(" "),a("h3",{attrs:{id:"get-applicable-actions-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-applicable-actions-6"}},[e._v("#")]),e._v(" _get_applicable_actions "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_applicable_actions",sig:{params:[{name:"self"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of applicable actions in the given memory (state or history), or in\nthe internal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events._get_applicable_actions()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._get_applicable_actions_from()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute\ninstead of the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-34"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-34"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-43"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-43"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of applicable actions.")]),e._v(" "),a("h3",{attrs:{id:"get-applicable-actions-from-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-applicable-actions-from-3"}},[e._v("#")]),e._v(" _get_applicable_actions_from "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_applicable_actions_from",sig:{params:[{name:"self"},{name:"memory",annotation:"D.T_memory[D.T_state]"}],return:"D.T_agent[Space[D.T_event]]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of applicable actions in the given memory (state or history).")]),e._v(" "),a("p",[e._v("This is a helper function called by default from "),a("code",[e._v("Events._get_applicable_actions()")]),e._v(", the difference being that\nthe memory parameter is mandatory here.")]),e._v(" "),a("h4",{attrs:{id:"parameters-35"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-35"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-44"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-44"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of applicable actions.")]),e._v(" "),a("h3",{attrs:{id:"get-enabled-events-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-enabled-events-6"}},[e._v("#")]),e._v(" _get_enabled_events "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_enabled_events",sig:{params:[{name:"self"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"Space[D.T_event]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of enabled uncontrollable events in the given memory (state or\nhistory), or in the internal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events._get_enabled_events()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._get_enabled_events_from()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute\ninstead of the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-36"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-36"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-45"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-45"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of enabled events.")]),e._v(" "),a("h3",{attrs:{id:"get-enabled-events-from-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-enabled-events-from-3"}},[e._v("#")]),e._v(" _get_enabled_events_from "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_get_enabled_events_from",sig:{params:[{name:"self"},{name:"memory",annotation:"D.T_memory[D.T_state]"}],return:"Space[D.T_event]"}}}),e._v(" "),a("p",[e._v("Get the space (finite or infinite set) of enabled uncontrollable events in the given memory (state or\nhistory).")]),e._v(" "),a("p",[e._v("This is a helper function called by default from "),a("code",[e._v("Events._get_enabled_events()")]),e._v(", the difference being that the\nmemory parameter is mandatory here.")]),e._v(" "),a("h4",{attrs:{id:"parameters-37"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-37"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-46"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-46"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("The space of enabled events.")]),e._v(" "),a("h3",{attrs:{id:"is-action-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-action-6"}},[e._v("#")]),e._v(" _is_action "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_is_action",sig:{params:[{name:"self"},{name:"event",annotation:"D.T_event"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an event is an action (i.e. a controllable event for the agents).")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("By default, this function is implemented using the "),a("code",[e._v("skdecide.core.Space.contains()")]),e._v(" function on the domain\naction space provided by "),a("code",[e._v("Events._get_action_space()")]),e._v(", but it can be overridden for faster implementations.")])]),e._v(" "),a("h4",{attrs:{id:"parameters-38"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-38"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("event")]),e._v(": The event to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-47"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-47"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the event is an action (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-applicable-action-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-applicable-action-6"}},[e._v("#")]),e._v(" _is_applicable_action "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_is_applicable_action",sig:{params:[{name:"self"},{name:"action",annotation:"D.T_agent[D.T_event]"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an action is applicable in the given memory (state or history), or in the internal one if\nomitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events._is_applicable_action()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._is_applicable_action_from()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute\ninstead of the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-39"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-39"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-48"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-48"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the action is applicable (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-applicable-action-from-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-applicable-action-from-3"}},[e._v("#")]),e._v(" _is_applicable_action_from "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_is_applicable_action_from",sig:{params:[{name:"self"},{name:"action",annotation:"D.T_agent[D.T_event]"},{name:"memory",annotation:"D.T_memory[D.T_state]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an action is applicable in the given memory (state or history).")]),e._v(" "),a("p",[e._v("This is a helper function called by default from "),a("code",[e._v("Events._is_applicable_action()")]),e._v(", the difference being that the\nmemory parameter is mandatory here.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("By default, this function is implemented using the "),a("code",[e._v("skdecide.core.Space.contains()")]),e._v(" function on the space of\napplicable actions provided by "),a("code",[e._v("Events._get_applicable_actions_from()")]),e._v(", but it can be overridden for faster\nimplementations.")])]),e._v(" "),a("h4",{attrs:{id:"parameters-40"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-40"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-49"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-49"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the action is applicable (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-enabled-event-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-enabled-event-6"}},[e._v("#")]),e._v(" _is_enabled_event "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_is_enabled_event",sig:{params:[{name:"self"},{name:"event",annotation:"D.T_event"},{name:"memory",default:"None",annotation:"Optional[D.T_memory[D.T_state]]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an uncontrollable event is enabled in the given memory (state or history), or in the\ninternal one if omitted.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("Events._is_enabled_event()")]),e._v(" provides some boilerplate code and internally\ncalls "),a("code",[e._v("Events._is_enabled_event_from()")]),e._v(". The boilerplate code automatically passes the "),a("code",[e._v("_memory")]),e._v(" attribute instead\nof the memory parameter whenever the latter is None.")]),e._v(" "),a("h4",{attrs:{id:"parameters-41"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-41"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider (if None, the internal memory attribute "),a("code",[e._v("_memory")]),e._v(" is used instead).")])]),e._v(" "),a("h4",{attrs:{id:"returns-50"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-50"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the event is enabled (False otherwise).")]),e._v(" "),a("h3",{attrs:{id:"is-enabled-event-from-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-enabled-event-from-3"}},[e._v("#")]),e._v(" _is_enabled_event_from "),a("Badge",{attrs:{text:"Events",type:"warn"}})],1),e._v(" "),a("skdecide-signature",{attrs:{name:"_is_enabled_event_from",sig:{params:[{name:"self"},{name:"event",annotation:"D.T_event"},{name:"memory",annotation:"D.T_memory[D.T_state]"}],return:"bool"}}}),e._v(" "),a("p",[e._v("Indicate whether an event is enabled in the given memory (state or history).")]),e._v(" "),a("p",[e._v("This is a helper function called by default from "),a("code",[e._v("Events._is_enabled_event()")]),e._v(", the difference being that the\nmemory parameter is mandatory here.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("By default, this function is implemented using the "),a("code",[e._v("skdecide.core.Space.contains()")]),e._v(" function on the space of\nenabled events provided by "),a("code",[e._v("Events._get_enabled_events_from()")]),e._v(", but it can be overridden for faster\nimplementations.")])]),e._v(" "),a("h4",{attrs:{id:"parameters-42"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-42"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("memory")]),e._v(": The memory to consider.")])]),e._v(" "),a("h4",{attrs:{id:"returns-51"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-51"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[e._v("True if the event is enabled (False otherwise).")])],1)}),[],!1,null,null,null);t.default=n.exports}}]);