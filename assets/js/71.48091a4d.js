(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{585:function(a,t,n){"use strict";n.r(t);var e=n(38),i=Object(e.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"hub-domain-flight-planning-graph"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hub-domain-flight-planning-graph"}},[a._v("#")]),a._v(" hub.domain.flight_planning.graph")]),a._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[a._v("Domain specification")]),a._v(" "),n("skdecide-summary")],1),a._v(" "),n("h2",{attrs:{id:"calculate-grid-point-coords"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#calculate-grid-point-coords"}},[a._v("#")]),a._v(" calculate_grid_point_coords")]),a._v(" "),n("skdecide-signature",{attrs:{name:"calculate_grid_point_coords",sig:{params:[{name:"p0",annotation:"<class 'pygeodesy.ellipsoidalVincenty.LatLon'>"},{name:"p1",annotation:"<class 'pygeodesy.ellipsoidalVincenty.LatLon'>"},{name:"x_local_km",annotation:"<class 'float'>"},{name:"y_local_km",annotation:"<class 'float'>"},{name:"z_local_ft",annotation:"<class 'float'>"}],return:"tuple[float, float, float]"}}}),a._v(" "),n("p",[a._v("Calculates the geographical coordinates of a grid point.\nLateral displacement is perpendicular to the "),n("em",[a._v("current")]),a._v(' tangent of the great circle.\nThis method will show "fanning out" over long distances but is straightforward\nfor localized grid generation and matches your visual examples.')]),a._v(" "),n("p",[a._v("Args:\np0 (LatLon): The actual start point of the main flight.\np1 (LatLon): The actual end point of the main flight.\nx_local_km (float): Distance along the main path from p0.\ny_local_km (float): Lateral offset in km (negative for left, positive for right).\nz_local_ft (float): Altitude in feet for this grid point.")]),a._v(" "),n("p",[a._v("Returns:\nTuple[float, float, float]: A tuple containing (latitude, longitude, altitude in feet)\nfor the calculated grid point.")]),a._v(" "),n("h2",{attrs:{id:"create-flight-graph"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#create-flight-graph"}},[a._v("#")]),a._v(" create_flight_graph")]),a._v(" "),n("skdecide-signature",{attrs:{name:"create_flight_graph",sig:{params:[{name:"p0",annotation:"<class 'pygeodesy.ellipsoidalVincenty.LatLon'>"},{name:"p1",annotation:"<class 'pygeodesy.ellipsoidalVincenty.LatLon'>"},{name:"nb_forward_points",default:"10",annotation:"<class 'int'>"},{name:"nb_lateral_points",default:"5",annotation:"<class 'int'>"},{name:"nb_climb_descent_steps",default:"3",annotation:"<class 'int'>"},{name:"flight_levels_ft",default:"None",annotation:"typing.Optional[list[float]]"},{name:"graph_width",default:"medium",annotation:"<class 'str'>"}],return:"<class 'networkx.classes.digraph.DiGraph'>"}}}),a._v(" "),n("p",[a._v("Creates a symmetric 3D directed graph representing potential flight paths between two points,\nwith phase-aware node generation and edge connectivity.")]),a._v(" "),n("h2",{attrs:{id:"prune-graph"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#prune-graph"}},[a._v("#")]),a._v(" prune_graph")]),a._v(" "),n("skdecide-signature",{attrs:{name:"prune_graph",sig:{params:[{name:"G",annotation:"<class 'networkx.classes.digraph.DiGraph'>"}],return:"<class 'networkx.classes.digraph.DiGraph'>"}}}),a._v(" "),n("p",[a._v("Removes iteratively nodes that do not have any parent or child node (dead-ends),\nexcluding the start and end nodes.")]),a._v(" "),n("p",[a._v("Args:\nG (nx.DiGraph): The input flight graph.")]),a._v(" "),n("p",[a._v("Returns:\nnx.DiGraph: The pruned graph.")])],1)}),[],!1,null,null,null);t.default=i.exports}}]);